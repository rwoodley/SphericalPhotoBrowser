<html>
<head>
<script type="text/javascript" src="lib/jquery-3.1.0.min.js"></script>
</head>
<body>
  <div id="theater">
    <canvas id="canvas" style="border: 5px solid black"></canvas>
    <label>
      <br />Press r to start/pause. Press S to extract coords.</label>
    <br />
  </div>
  <div id='status'></div>
  <div id='output'></div>
<script>
var _canvas = document.getElementById('canvas');
var _ctx = canvas.getContext('2d');
var cscale = 1;
var _canvasWidth = 720*cscale;
var _canvasHeight = 360*cscale;
var PI = Math.PI;
this.complex = function(x,y) {
  var a = this;
  this.x = x; this.y = y;
  this.mult = function(b) {
    var x = a.x*b.x-a.y*b.y;
    var y = a.x*b.y+a.y*b.x;
    return new complex(x,y);
  }
  this.add = function(b) {
    return new complex(a.x+b.x,a.y+b.y);
  }
  this.divide = function(b) {
    var x = (a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y);
    var y = (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y);
    return new complex(x,y);
  }
}
var _one = new complex(1,0); var _i = new complex(0,1); var _zero = new complex(0,0);
this.xform = function(a,b,c,d) {
  var self = this;
  this.a = a; this.b = b; this.c = c; this.d = d;
  this.doit = function(z) {
    var num = self.a.mult(z).add(self.b);
    var den = self.c.mult(z).add(self.d);
    return num.divide(den);
  }
}
gen = function() {
  var _self = this;
  this.xform = new xform(_i,_zero,_one,_one);
  this.cartesianToPolar = function(x,y,z) {
    var theta;
    var phi;
    phi = Math.atan2(y, x);
    phi -= (PI/2.0);    // this correction lines up the UV texture nicely.
    if (phi <= 0.0) {
        phi = phi + PI*2.0; 
    }
    if (phi >= (2.0 * PI)) {    // allow 2PI since we gen uv over [0,1]
        phi = phi - 2.0 * PI;
    }
    phi = 2. * PI - phi;        // flip the texture around.
    theta = Math.acos(z);
    return [phi, theta];
  }
  this.complexToUV = function(inx,iny) {
    // now c back to sphere.
    var theta;
    var phi;
    var x;
    var y;
    var z;
    var denom = 1.0 + inx * inx + iny * iny;
    x = 2.0 * inx/denom;
    y = 2.0 * iny/denom;
    z = (inx*inx + iny*iny - 1.0)/denom;
    // console.log(x,y,z);

    // convert to polar
    var polarCoords = _self.cartesianToPolar(x,y,z);
    phi = polarCoords[0];
    theta = polarCoords[1];
    // console.log(phi, theta);

    // now get uv in new chart.
    var newv = theta/PI;
    var newu = phi/(2.0 * PI);
    return [newu, newv];
  }
  this.drawGrid = function() {
    for (i = 0; i < _canvasHeight; i+=10) {
      _ctx.beginPath();
      _ctx.moveTo(0, i);
      _ctx.lineTo(_canvasWidth,i);
      _ctx.stroke();
      // console.log(i);
    }
  }
  this.drawCPoint = function(x,y) {
    var xpt = this.xform(new complex(x,y));
    var pt = _self.complexToUV(xpt.x,xpt.y);
    _ctx.beginPath();
    console.log(pt[0],pt[1]);
    _ctx.arc(
      pt[0]*_canvasWidth, 
      pt[1]*_canvasHeight,
      10,2*Math.PI, false);
    _ctx.fill();
  }
  this.uvToCanvas = function(pt) {
    return [pt[0]*_canvasWidth, pt[1]*_canvasHeight];
  }
  this.drawCline = function(x1,y1,x2,y2) {
    _ctx.fillStyle = 'Green';
    var m = (y2-y1)/(x2-x1);
    var iter=200
    _ctx.strokeStyle = 'Red';
    _ctx.beginPath();
    var incr = (x2-x1)/iter;
    var nx = x1;
    for (var i = 0; i <= iter; i++) {
      var nx = nx + Math.max(0.01,Math.abs(nx)*incr/5);
      if (nx > x2) break;
      var ny = m*nx+y1;
      // nx = Math.log(Math.abs(nx))*Math.sign(nx);
      // ny = Math.log(Math.abs(ny))*Math.sign(ny);
      var xpt = this.xform.doit(new complex(nx,ny));
      var pt = _self.uvToCanvas( _self.complexToUV(xpt.x,xpt.y));
      if (i == 0)
        _ctx.moveTo(pt[0], pt[1]);
      else
        _ctx.lineTo(pt[0], pt[1]);
      // this.drawCPoint(nx, ny);
      console.log('--->',nx,ny);
    }
    _ctx.stroke();
    _ctx.strokeStyle = 'Black';
  }
  this.drawCLines = function() {
    for (i = 0; i < 10; i++) {
      _self.drawCline(-100,0.,100.,0.00);
      _self.xform = new xform(
        _self.xform.a,
        // _self.xform.b,
        _self.xform.b.add(_one),
        _self.xform.c,
        _self.xform.d
      );
    }
  }
  this.drawGrid();
  this.drawCLines();
  // _ctx.fillRect(25, 25, 100, 100);
}
$(function() {
  var that = this;
  var mousePos;
  var _coords = [];
  var _playbackMode=false;
  document.getElementsByTagName( 'canvas' )[0].style.width = _canvasWidth + "px";
  document.getElementsByTagName( 'canvas' )[0].style.height = _canvasHeight + "px";
  canvas.width = _canvasWidth;
  canvas.height = _canvasHeight;
  document.body.onkeydown = function(e){
      console.log(e.keyCode);
  };
  var xx = new gen();
  xx.drawGrid();
});
</script>
</body>
</html>
