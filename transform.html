<!DOCTYPE html>
<html >
	<head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <style>
			body {
				font-family: Arial  ;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
            .availableMediaPanel {
                position: fixed;
                top: 0;
                width: 95%;
            }
            .availableMediaPanelInner {
                width: 90%;
                margin: 0 auto;             
            }
            .videoPanel {
                position: fixed;
                bottom: 40%;
                width: 95%;
            }
            .cameraPanel {
                position: fixed;
                bottom: 0%;
                width: 95%;
            }
            .transformPanel {
                position: fixed;
                bottom: 30%;
                width: 95%;
            }
            .complexPanel {
                position: fixed;
                bottom: 20%;
                width: 95%;
            }
            .transformPanel2 {
                position: fixed;
                bottom: 10%;
                width: 95%;
            }
            .centerAlign {
                width: 95%;
                margin: 0 auto;             
            }
            .statusText {
                height:30px;
                width:300px;
                color: #00ff00;
                padding: 5px;
                background-color: black;
                display: none;
            }
            .wideLabel {
                width: 80px !important;
            }
            #statsDiv {
                position: fixed;
                bottom: 0;
                z-index:  100;
                width: 100%;
            }
            #statsDivInner {
                float: right;                
            }
		</style>
        <link rel="stylesheet" type="text/css" href="mediaUtils.css">
        <link rel="stylesheet" type="text/css" href="transformUtils.css">
		<script src="r73/three.js"></script>
        <script src="r73/OrbitControls.js"></script>
		<script src="r73/Detector.js"></script>
		<script src="r73/ParametricGeometries.js"></script>
 		<script src="r73/stats.min.js"></script>
		<script src="lib/jquery-3.1.0.min.js"></script>
        <script src="lib/toast.js"></script>
        <script src="myGeometries.js"></script>

        <script src="shaderCode/main.js"></script>
        <script src="shaderCode/droste.js"></script>
        <script src="shaderCode/mathUtils.js"></script>

        <script src="mediaUtils.js"></script>
        <script src="transformUtils.js"></script>
        <script src="utils.js"></script>

        
        <script src="media/files.js"></script>
        <script src="media/videos.js"></script>
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41066114-3', 'auto');
  ga('send', 'pageview');

</script>


        <script id="vs_simple" type="x-shader/x-vertex">
            varying vec2 vUv; 
            void main()
            {
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
                vUv = uv;
            }
        </script>
        <script id="fs_simple" type="x-shader/x-fragment">
            uniform sampler2D iChannel0;
            varying vec2 vUv;  
            void main()
            {
                vec2 uv = vUv;
                vec4 tex1 = texture2D( iChannel0,  uv);
                gl_FragColor = vec4(tex1.r,0.,0.,1.);
            }
        </script>
        <script id="vs" type="x-shader/x-vertex">
            varying vec2 vUv; 
            void main()
            {
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );
                gl_Position = projectionMatrix * mvPosition;
                vUv = uv;
            }
        </script>

        <script id="fs" type="x-shader/x-fragment">


           // ====== Transformation Code
            struct xform { vec2 a; vec2 b; vec2 c; vec2 d; };
            
            xform xformCtor(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {
                xform x;
                x.a = a; x.b = b; x.c = c; x.d = d;
                return x;
            }
            xform inverseXformCtor(xform x) {
                return xformCtor(x.d,-x.b,-x.c,x.a);
            }
            vec2 applyMobiusTransformation(in vec2 z, in xform t) {
                vec2 top = cx_product(z,t.a)+t.b;
                vec2 bottom = cx_product(z,t.c)+t.d;
                return cx_divide(top,bottom);
            }
            vec2 applyInverseMobiusTransformation(in vec2 z, xform x) {
                // inverse is (dz-b)/(-cz+a).
                return applyMobiusTransformation(z,xformCtor(x.d,-x.b,-x.c,x.a));
            }
            vec2 transformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {
                return applyMobiusTransformation(z,xformCtor(one,-e1,one,-e2));
            }
            vec2 inverseTransformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {
                // inverse is (dz-b)/(-cz+a). a and c are 1.
                return applyInverseMobiusTransformation(z,xformCtor(one,-e1,one,-e2));
            }
            vec2 applyRotation(in vec2 z, in float radians) {
                // vec2 exp = cx_exp(vec2(0.,radians));
                vec2 exp = vec2(cos(radians), sin(radians));
                vec2 ans = cx_product(z, exp);
                return ans;
            }
            vec2 zoom(in vec2 z, in vec2 zoomDegree) {
                // a real zoomDegree is a streight zoom without twist.
                // a complex zoomDegree has a twist!
                vec2 ans = cx_product(zoomDegree,z);
                 ans = cx_product(zoomDegree,ans);
                return ans;
            }
            vec2 anotherTransform(vec2 z) {
                vec2 n = z-i;
                vec2 d = z+i;
                vec2 f = cx_divide(n,d);
                vec2 res = 1. * cx_exp(4.*f);
                return res;
            }

struct circle {
    vec2 center;
    float radius;
};
struct childCircle {
    circle c;
    xform x;
};
childCircle children[100];
int nChildren;
struct circleGroup {
    circle a;   // 0
    circle A;   // 1
    circle b;
    circle B;
};
circleGroup level1[4];
circleGroup initialCircles;
float xtheta = 3.14159/4.;
xform group_a;
xform group_b;
xform group_A;
xform group_B;
xform xFormForIndex[4];  // group_a, A, b, B
circle mobiusOnCircle(xform T, circle C) { // indra's pearls, page 91
    circle D;
    vec2 z;
    vec2 zdenom = cx_conjugate(vec2(cx_divide(T.d, T.c) + C.center));
    z = C.center - cx_divide(vec2(C.radius * C.radius,0.), zdenom);
    D.center = applyMobiusTransformation(z, T);
    D.radius = cx_modulus(D.center - applyMobiusTransformation(C.center + C.radius, T));
    return D;
}
void addChildCircle(int xFormIndex, int circleType, circle c) {
    // TODO: exclude inverses, etc.
/*
    xform x = xFormForIndex[xFormIndex];
    circle child = mobiusOnCircle(x, c);
    childCircle a;
    a.c = child;
    a.x  = x;
    children[nChildren] = a;
    nChildren++;
*/
}

void defineInitialCircles() {
    float xradius = 1.;
    float xctr = 1./cos(xtheta);
    float s2 = sqrt(2.0);
    initialCircles.b.center = vec2(-s2,0.);
    initialCircles.b.radius = xradius;
    initialCircles.B.center = vec2(s2,0.);
    initialCircles.B.radius = xradius;

    initialCircles.a.center = -i*s2;
    initialCircles.a.radius = xradius;
    initialCircles.A.center = i*s2;
    initialCircles.A.radius = xradius;
    float cnst = 1./sin(xtheta);
    cnst = 1.;
    group_b = xformCtor(
                        vec2(s2,0.), 
                        one,
                        one,
                        vec2(s2,0.));
    group_B = inverseXformCtor(group_b);
    group_a = xformCtor(
                        vec2(s2,0.), 
                        i,
                        -i,
                        vec2(s2,0.));
    group_A = inverseXformCtor(group_a);
    xFormForIndex[0] = group_a;
    xFormForIndex[1] = group_A;
    xFormForIndex[2] = group_b;
    xFormForIndex[3] = group_B;

    nChildren = 0;
    for (int i = 0; i < 4; i++) {
        addChildCircle(i, 0, initialCircles.a);
        addChildCircle(i, 1, initialCircles.A);
        addChildCircle(i, 2, initialCircles.b);
        addChildCircle(i, 3, initialCircles.B);
    }
}
bool insideCircle(circle a, vec2 z) {
    return distance(z,a.center) < a.radius;
}
vec2 schottkyGroup(in vec2 z, in vec2 s, in vec2 t, int index) {
    if (index > 0)
        z = applyMobiusTransformation(z, group_a);
   if (index < 0)
        z = applyInverseMobiusTransformation(z, group_a);
    return z;
}
vec4 highlightInnerCircle(vec2 z) {
    circle c = initialCircles.A;
    circle c1 = mobiusOnCircle(group_a, c);

    if (insideCircle(c1, z)) {
        return vec4(0,.0,1.,1.);
    }
    if (insideCircle(c, z)) {
        return vec4(1.,.0,0.,1.);
    }
    return vec4(0.,1.,0.,1.);
}
vec2 applyInverseSchottkyTransformForCircle(vec2 z, int i) {
    if (i == 0)
        z = applyInverseMobiusTransformation(z, group_a);
    if (i == 1)
        z = applyInverseMobiusTransformation(z, group_b);
    if (i == 2)
        z = applyInverseMobiusTransformation(z, group_A);
    if (i == 3)
        z = applyInverseMobiusTransformation(z, group_B);
    return z;
}
vec4 getTextureColor(vec2 z) {
    if (insideCircle(initialCircles.a, z)) {
        return vec4(1.,1.,0.,1.);
    }
    if (insideCircle(initialCircles.A, z)) {
        return vec4(0.,1.,0.,1.);
    }
    if (insideCircle(initialCircles.b, z)) {
        return vec4(0.,1.,1.,1.);
    }
    if (insideCircle(initialCircles.B, z)) {
        return vec4(0.,0.,1.,1.);
    }
    return vec4(0.,0.,0.,1.);
}
vec4 applySchottky(in vec2 z) {
    defineInitialCircles();

  //  vec4 clr = highlightInnerCircle(z);

  // group_a takes A to a, normally. a1
  // we're starting with z on C, and want to get the right color, by unwinding xforms.
  // if inside circle, apply reverse xform(s) to get to color.

        if (insideCircle(initialCircles.a, z) == true)     // in a1, apply 2: group_a takes a1 to a2. should be: group_A takes a to A.
    z = applyInverseSchottkyTransformForCircle(z, 2);          
    else if (insideCircle(initialCircles.b, z) == true)
    z = applyInverseSchottkyTransformForCircle(z, 3);
    else if (insideCircle(initialCircles.A, z) == true)
    z = applyInverseSchottkyTransformForCircle(z, 0);
    else if (insideCircle(initialCircles.B, z) == true)
    z = applyInverseSchottkyTransformForCircle(z, 1);
    else {
        return vec4(1.,1.,1.,1.);
    }
    vec4 clr = getTextureColor(z);
    return clr;
}
            void main() {
                 float theta;
                 float phi;
                 float x;
                 float y;
                 float z;

                vec2 uv = vUv;
                uv.x = clamp(uv.x,0.001,.999);

                // ---------
                // convert from uv to polar coords
                vec2 tempuv = uv;
                theta = (1.0-tempuv[1]) * PI;
                phi = PI * 2.0 * tempuv[0]+PI;

                // convert polar to cartesian. Theta is polar, phi is azimuth.
                x = sin(theta)*cos(phi);
                y = sin(theta)*sin(phi);
                z = cos(theta);

                // x,y,z are on the unit sphere.
                // if we pretend that sphere is a riemann sphere, then we
                // can get the corresponding complex point, a.
                // http://math.stackexchange.com/questions/1219406/how-do-i-convert-a-complex-number-to-a-point-on-the-riemann-sphere

                // we added the PI to phi above to make the Y axis correspond with
                // the positive imaginary axis and the X axis correspond with
                //  the positive real axis. So flip y and x around in this next equation.
                vec2 a = vec2(y/(1.0-z), x/(1.0-z));

                vec2 result = a;
                //gl_FragColor = applySchottky(a);
                //return;
                //if (complexEffect5OnOff == 1) {
                    //a = applySchottky(a);
                //}

                vec2 e1 = vec2(e1x,e1y);
                vec2 e2 = vec2(e2x,e2y);
                vec3 e1InCartesian = complexToCartesian(e1);
                vec3 e2InCartesian = complexToCartesian(e2);
                vec3 aInCartesian = complexToCartesian(a);
                if (mobiusEffectsOnOff == 1) {
                    vec2 lox = vec2(loxodromicX, loxodromicY);
                    if (showFixedPoints) {

                        if (distance(aInCartesian, e1InCartesian) < .05) {
                            gl_FragColor = vec4(1.,0.,0.,1.);
                            return;
                        }
                        if (distance(aInCartesian, e2InCartesian) < .05) {
                            gl_FragColor = vec4(0.,0.,1.,1.);
                            return;
                        }                       
                        if (distance(aInCartesian, complexToCartesian(lox)) < .05) {
                            gl_FragColor = vec4(1.,1.,0.,1.);
                            return;
                        }                       
                    }

                    vec2 b = transformForFixedPoints(a, e1, e2);
                    vec2 c;
                    vec2 b1 = applyRotation(b,iRotationAmount/10.);
                    c = zoom(b1, vec2(loxodromicX, loxodromicY));

                    if (drosteType == 1)
                        c = applyRoundDroste(c);
                    if (drosteType == 2) {
                        c = applyArbitraryDroste(c);
                        //gl_FragColor = vec4(c.x/(PI/4.),0.,0.,1.);
                        //return;
                    }
                    if (complexEffect5OnOff == 1) {
                        //c = schottky(c);
                    }
                    result = inverseTransformForFixedPoints(c, e1, e2);
                }
                vec2 realNumber = vec2(complexEffect1OnOff, 0.);
                result = cx_pow(result, realNumber);                    
                if (complexEffect3OnOff == 1) {
                    result = anotherTransform(result);
                }
                if (complexEffect4OnOff == 1) {
                    result = cx_exp(result);
                }

                // // // // now c back to sphere.
                float denom = 1.0 + result.x*result.x + result.y *result.y;
                x = 2.0 * result.x/denom;
                y = 2.0 * result.y/denom;
                z = (result.x*result.x + result.y*result.y - 1.0)/denom;

                // convert to polar
                phi = atan2(y, x);
                phi -= (PI/2.0);    // this correction lines up the UV texture nicely.
                if (phi <= 0.0) {
                    phi = phi + PI*2.0; 
                }
                if (phi >= (2.0 * PI)) {    // allow 2PI since we gen uv over [0,1]
                    phi = phi - 2.0 * PI;
                }
                phi = 2. * PI - phi;        // flip the texture around.
                theta = acos(z);

                // now get uv in new chart.
                float newv = 1.0 - theta/PI;
                float newu = phi/(2.0 * PI);
                vec2 newuv = vec2(newu, newv);
                vec4 tex1 = texture2D( iChannel0,  newuv);
                gl_FragColor = tex1;
            }

        </script>
		<script>
			var _container, _stats;
			var _camera, _controls, _scene, _renderer, _clock, _mediaUtils, _transformUtils;
			var myMesh;
			function init() {
                if ( ! Detector.webgl ) {
                    Detector.addGetWebGLMessage();
                    document.getElementById( 'container' ).innerHTML = "";
                }

                _clock = new THREE.Clock();
                _container = document.getElementById( 'container' );

                _camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 20000 );

                _scene = new THREE.Scene();
                _controls = new THREE.OrbitControls( _camera, _container.domElement );
                _axes = new THREE.AxisHelper( 15000 );
                _scene.add(_axes);
                _renderer =  new THREE.WebGLRenderer({ antialias: true } );
                _mediaUtils = new mediaUtils(
                    _scene, 
                    _camera, 
                    myTextures, 
                    myVideos, 
                    "mediaListContainer", 
                    "cameraControlsContainer",
                    "videoControlsContainerId");

                _transformUtils = new transformUtils(_camera, 
                    "transformControlsContainerId", 
                    "complexControlsContainerId", 
                    "transformControls2ContainerId",
                    _mediaUtils);

                _camera.position.x = -1; _camera.position.y = 0.0; _camera.position.z = 0;
                _renderer.setSize( window.innerWidth, window.innerHeight );

                document.getElementById( 'container' ).innerHTML = "";
                _container.appendChild( _renderer.domElement );

                var skyMaterial = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide});
                var skyGeometry = new THREE.SphereGeometry(100,32,32);
                var skyMesh = new THREE.Mesh( skyGeometry, skyMaterial );
                _scene.add(skyMesh);
                
                _stats = new Stats();
                document.getElementById('statsDivInner').appendChild( _stats.domElement );    

                animate();
			}

			function animate() {
				requestAnimationFrame( animate );
				_controls.update( _clock.getDelta() );
				_renderer.render( _scene, _camera );
                _transformUtils.animate();
                _stats.update();
			}
            $().ready(function() {
                init();
            });
</script>
</head>
	<body>
		<video  id="video"
		  style="display: none;
		  position: absolute; left: 15px; top: 75px;"
		  controls="true" autoplay="true">
		</video>
		<div id="container"><br /><br /><br /><br /><br />Generating...</div>

        <div style="position: fixed; top: 20%; width:95%; ">
             <div id='cameraText' class="statusText"></div>
             <div id='unitVectorText' class="statusText"></div>
             <div id='complexPointText' class="statusText"></div>
        </div>
        <div class="availableMediaPanel ">
            <div class="centerAlign">
                <div id="mediaListContainer" >
                    <span class='showhide wideLabel mediaLabel label'>Stills/Videos:</span>
                </div>
            </div>
        </div>
        <div class="transformPanel">
            <div class="centerAlign">
                <div id="transformControlsContainerId">
                    <span class='showhide wideLabel label'>M&ouml;bius transforms:</span>
                </div>
            </div>
        </div>
        <div class="complexPanel">
            <div class="centerAlign">
                <div id="complexControlsContainerId">
                    <span class='showhide wideLabel label'>Complex transforms:</span>
                </div>
            </div>
        </div>
        <div class="videoPanel">
            <div class="centerAlign">
                <div id="videoControlsContainerId">
                    <span class='showhide wideLabel label'>Video controls:</span>
                </div>
            </div>
        </div>
        <div class="transformPanel2">
            <div class="centerAlign">
                <div id="transformControls2ContainerId">
                    <span class='showhide wideLabel label'>Reset, toggle, etc:</span>
                </div>
            </div>
        </div>
        <div class="cameraPanel">
            <div class="centerAlign">
                <div id="cameraControlsContainer">
                    <span class='showhide wideLabel label'>Camera controls:</span>
                    <span id="statsDivInner" class="showhide">
                    </span>
                </div>
            </div>
        </div>
        <script>
        </script>
	</body>
</html>
